[user]
name = "Felipe Moran"
email = "felipe@tensor.so"

[signing]
behavior = "own"
backend = "gpg"
key = "F571B38795ECCCDC"

[ui]
default-command = ["log", "-r", "(stack() ~(::remote_bookmarks())) | (stack() & remote_bookmarks()) | description('MEGA MERGE')-", "-T", "home_log"]
color = "always"
editor = "vim"
diff-editor = "webstorm"
merge-editor = "webstorm"
diff-formatter = "webstorm"
paginate = "never"
log-word-wrap = true
#conflict-marker-style = "git"

[merge-tools.webstorm]
program = "/Applications/WebStorm.app/Contents/MacOS/webstorm"
edit-args = ["diff", "$left", "$right"]
merge-args = ["merge", "$right", "$left", "$base", "$output"]
diff-args = ["diff", "$left", "$right"]

[git]
# Prevent pushing work in progress or anything explicitly labeled "private"
private-commits = "description(glob:'WIP*') | description(glob:'MQ*') | description(glob:'private:*') | description(glob:'---*') | description(glob:'BLOCKED*')"
write-change-id-header = true


[aliases]
e = ["edit"]
# shots all related commits in one grapg. This is designed to work with a (mostly empty) mega-merge commit that merges multiple
# individual PR branches. Above the mega merge commit it's recommended to keep a sequence of WIP commits or commits that are
# ready for review, but waiting on dependencies to be merged.
# Example:
# ○  xvoqrq felipe 1 month ago 2a2989
# │  WIP TODOs
# @  uqypuk felipe now 2509aa
# │  WIP MY FEATURE
# @  xvoqrq felipe now 2509aa
# │  Something waiting on PRs to be merged before review
# ○    tswyzk felipe 1 month ago git_head() ad7fbf
# ├─╮  (empty) ------ WIP MEGA MERGE ------
# │ ◆  uxnnmr felipe 14 hours ago felipe/my branch
# │ │  195e26
# │ │  Fix duplicated user swaps
# │ ◆  sssrnk felipe 1 month ago dea18f
# │ │  Fix ETH user swaps containing entries related to other bridges
# │ ~
# │
# ○  tyslps felipe 1 month ago 6e4baf
# │  DEV CHANGES (collection of local changes for dev only)
# ~

stack = ["log", "-r", "stack()"]
fixpr = ["new", "-m", "Fix PR", "-A"]
fix-pr = ["new", "-m", "Fix PR", "-A"]
prune = ["abandon", "-r", "empty() & stack() & description(regex:'^$')"]

up = ["edit", "@+"]
down = ["edit", "@-"]
simplify = ["simplify-parents", "-s", "description('MEGA MERGE') & stack() & mutable()"]

# pull bookmarks from ancestors to current commit (works best when there's a single bookmark)
#tug = ["bookmark", "move", "--from", "closest_bookmark(@- ~ description('MEGA MERGE')::) & bookmarks(glob:'felipe/*')", "--to", "@"]
tug = ["bookmark", "move", 'glob:felipe/*', "--from", "closest_bookmark(@ ~ description('MEGA MERGE')::) & stack()", "--to", "@"]
tug-any = ["bookmark", "move", "--from", "closest_bookmark(@ ~ description('MEGA MERGE')::) & stack()", "--to", "@"]
push = ["git", "push", "-N"]
# run after jj git fetch to update working tree
retrunk = ["rebase", "-d", "trunk()", "-s", "stack()~stack()+~immutable()"]
retrunk-megamerge = ['rebase', '-s', 'megamerge()', '-d', 'megamerge()-', '-d', 'heads(stack() ~ megamerge():: ~ DEV_CHANGES::)']
# prepare commits for PR (needs -r flag)
prepare = ["rebase", "-B", "description('MEGA MERGE') & stack()", "-A", "trunk()"]
prep = ["prepare"]
preparethis = ["rebase", "-B", "description('MEGA MERGE') & stack()", "-A", "trunk()", "-r", "@"]
prepthis = ["preparethis"]
bc=["b", "c", "-r", "@"]
# rebases commits also on top of main for fixing PR conflicts without rebasing the entire branch and force-pushing
rebase-trunk = ["rebase", "-s", "@", "-d", "@-", "-d", "trunk()"]

open = ["log", "-r", "open() & committer_date(after:'7 days ago')"]
open-all = ["log", "-r", "open()"]
open-stale = ["log", "-r", "open() & committer_date(before:'7 days ago')"]

unmerge = ["rebase", "-s", "description('MEGA MERGE')", "-d", "description('MEGA MERGE')-"]

[revset-aliases]
#"parents()" = "trunk()..@-"

#"immutable_heads()" = "builtin_immutable_heads() | (trunk().. & ~mine())"
"immutable_heads()" = "builtin_immutable_heads() | (trunk().. & ~mine()) | remote_bookmarks()"


'closest_bookmark(to)' = 'heads(::to & bookmarks())'

# stack(x, n) is the set of commits reachable from 'x' not on trunk(), with 'n'
# parents. 'n' is often useful to customize the display and return set for
# certain operations. 'x' can be used to target the set of 'roots' to traverse,
# e.g. @ is the current stack.
'stack()' = 'reachable(@, ~::trunk())'
'stack(x)' = 'reachable(x, ~::trunk())'
'stack(x, n)' = 'ancestors(reachable(x, ~::trunk()), n)'
'wipstack()' = "reachable(@, ~::description('MEGA MERGE'))"

# The current set of "open" works. It is defined as:
#
# - given the set of commits not in trunk, that are written by me,
# - calculate the given stack() for each of those commits
#
# n = 1, meaning that nothing from `trunk()` is included, so all resulting
# commits are mutable by definition.
'open()' = 'stack(trunk().. & mine(), 1)'

#'branchdiff()' = 'stack() ~..'
#'branchdiff(x)' = 'stack(x) ~x..'

'wipcurrent()' = 'stack() & description("WIP CURRENT")'

'megamerge()' = 'description("MEGA MERGE")'


[template-aliases]
'commit_timestamp(commit)' = '''
		if(commit.current_working_copy() || commit.hidden(),
			commit.committer().timestamp().ago(),
			commit.author().timestamp().ago()
		)
	'''
'format_shortest_change_id(id)' = 'id.shortest(1)'
'format_short_change_id(id)' = 'id.shortest(6)'
'format_short_change_id_with_hidden_and_divergent_info(commit)' = '''
		if(commit.hidden(),
			label("hidden",
				format_short_change_id(commit.change_id()) ++
				" hidden"
			),
			if(commit.divergent(),
				label("divergent",
					format_short_change_id(commit.change_id()) ++
					" " ++
					label("divergent_indicator", "DIVERGENT") ++
					" " ++
					label("divergent_commit_id", commit.commit_id().shortest(6))
				),
				format_short_change_id(commit.change_id())
			)
		)
	'''
'format_short_commit_id(id)' = 'id.shortest(6)'
'format_short_signature(signature)' = '''
		coalesce(signature.email().local(), email_placeholder)'''
'format_timestamp(timestamp)' = 'timestamp'


'format_description(description)' = '''
if(
    description,
    coalesce(
        if(
            self.contained_in('description("MEGA MERGE")'),
            label("WIP_ALL", "MEGA MERGE")
        ),
        if(
            self.contained_in('description("WIP") & description("MEGA MERGE")..'),
            label("WIP", description.first_line())
        ),
        if(
            self.contained_in('description("MQ") & description("MEGA MERGE")..'),
            label("MQ", description.first_line())
            ),
        if(
            self.contained_in('description("MEGA MERGE")..'),
            label("unknown", description.first_line())

        ),
        description.first_line()
    ),
    label(if(empty, "empty"), description_placeholder),
)
'''

files_per_change = '''
concat(
  change_id.shortest(8), "  ",
  description.first_line(), "\n",
  indent("  ", diff.summary()),
  "\n"
)
'''


home_log = '''
  if(root,
    format_root_commit(self),
    label(
      if(current_working_copy, "working_copy"),
      concat(
        separate(" ",
          format_short_change_id_with_hidden_and_divergent_info(self),
          if(
            empty,
            if(
                self.contained_in('description("MEGA MERGE")'),
                label("clean_merge_all", "(no changes)"),
                label("empty", "(no changes)")
            ),
            if(
                self.contained_in('description("MEGA MERGE")'),
                label("dirty_merge_all", "(Dirty MERGE ALL)"),
                ""
            ),
          ),
          if(
            self.contained_in('::remote_bookmarks()'),
            "",
            format_description(description)
          ),
          bookmarks,
          tags,
          working_copies,
          if(conflict, label("conflict", "(conflict)")),
          if(config("ui.show-cryptographic-signatures").as_boolean(),
            format_short_cryptographic_signature(signature)
          ),
          if(current_working_copy, "\n"),
        ),
      )
    )
  )
'''

log_prompt = '''
  if(root,
    format_root_commit(self),
    label(
      "prompt",
      concat(
        separate(" ",
          self.change_id().shortest(1),
          label(
            if(conflict, "conflict", "non_conflict"),
            stringify(format_description(description))
          ),
          if(empty, "(empty)"),
          bookmarks,
          tags,
          working_copies,
          if(conflict, label("conflict", "conflict")),
        ),
      )
    )
  )
'''

[templates]
log_node = '''
  label("node",
    coalesce(
      if(!self, label("elided", "~")),
      if(current_working_copy, label("working_copy", "@")),
      if(conflict, label("conflict", "×")),
      if(immutable, label("immutable", "◆")),
      if(self.contained_in('heads(stack())'), label("head", "╭")),
      label("normal", "├")
    )
  )
'''

#home_ = '''
#  if(root,
#    format_root_commit(self),
#    label(
#      if(current_working_copy, "working_copy"),
#      concat(
#        separate(" ",
#          format_short_change_id_with_hidden_and_divergent_info(self),
#          if(conflict, label(format_short_commit_id(commit_id), format_short_commit_id(commit_id))),
#          if(empty, label("empty", "(no changes)")),
#          format_description(description),
#          bookmarks,
#          tags,
#          working_copies,
#          if(conflict, label("conflict", "conflict")),
#          if(config("ui.show-cryptographic-signatures").as_boolean(),
#            format_short_cryptographic_signature(signature)
#          ),
#          if(current_working_copy, "\n"),
#        ),
#      )
#    )
#  )
#'''



# TODO: highlight dirty commits not in remote and below MEGA MERGE, excluding dev commits (optionally only with bookmarks)

[colors]
"empty description placeholder" = "yellow"
"working_copy empty description placeholder" = "red"
"working_copy description" = { fg = "bright green", italic = true, reverse = true }
"working_copy change_id" = { reverse = true, italic = true }
# "WIP" = { fg = "red", bold = false }
"WIP_ALL" = { fg = "white", bold = false }
"clean_merge_all" = { fg = "white", bold = false }
"MQ" = { fg = "cyan", bold = false }
# "unknown" = { fg = "yellow", bold = false }
"dirty_merge_all" = { fg = "bright yellow", reverse = true }

"prompt change_id" = { fg = "magenta", bold = false }
"prompt description" = { fg = "white", bold = false }
"prompt non_conflict" = { fg = "green", bold = false }

"working_copies" = { fg = "yellow", bold = true, underline = true, reverse = true }

# Divergent commit styling
"divergent" = { fg = "bright red", bold = true }
"divergent_indicator" = { fg = "bright red", bold = true, reverse = true }
"divergent_commit_id" = { fg = "bright yellow", bold = true }
