[user]
name = "Felipe Moran"
email = "felipe@tensor.so"

[signing]
behavior = "own"
backend = "gpg"
key = "F571B38795ECCCDC"

[ui]
default-command = ["stack"]
color = "always"
diff-editor = "webstorm"
merge-editor = "webstorm"
diff.tool = "webstorm"
paginate = "never"
log-word-wrap = true
conflict-marker-style = "git"

[merge-tools.webstorm]
program = "/Applications/WebStorm.app/Contents/MacOS/webstorm"
edit-args = ["diff", "$left", "$right"]
merge-args = ["merge", "$right", "$left", "$base", "$output"]
diff-args = ["diff", "$left", "$right"]

[git]
# Prevent pushing work in progress or anything explicitly labeled "private"
private-commits = "description(glob:'WIP*') | description(glob:'DEV*') | description(glob:'private:*') | description(glob:'---*') | description(glob:'BLOCKED*')"

[aliases]
e = ["edit"]
# shots all related commits in one grapg. This is designed to work with a (mostly empty) mega-merge commit that merges multiple
# individual PR branches. Above the mega merge commit it's recommended to keep a sequence of WIP commits or commits that are
# ready for review, but waiting on dependencies to be merged.
# Example:
# ○  xvoqrq felipe 1 month ago 2a2989
# │  WIP TODOs
# @  uqypuk felipe now 2509aa
# │  WIP MY FEATURE
# @  xvoqrq felipe now 2509aa
# │  Something waiting on PRs to be merged before review
# ○    tswyzk felipe 1 month ago git_head() ad7fbf
# ├─╮  (empty) ------ WIP MEGA MERGE ------
# │ ◆  uxnnmr felipe 14 hours ago felipe/my branch
# │ │  195e26
# │ │  Fix duplicated user swaps
# │ ◆  sssrnk felipe 1 month ago dea18f
# │ │  Fix ETH user swaps containing entries related to other bridges
# │ ~
# │
# ○  tyslps felipe 1 month ago 6e4baf
# │  DEV CHANGES (collection of local changes for dev only)
# ~

stack = ["log", "-r", "stack()"]
fixpr = ["new", "-m", "PR fix", "-A"]
fix-pr = ["new", "-m", "PR fix", "-A"]

up = ["edit", "@+"]
down = ["edit", "@-"]
simplify = ["simplify-parents", "-s", "description('WIP ALL') & stack() & mutable()"]

# pull bookmarks from ancestors to current commit (works best when there's a single bookmark)
tug = ["bookmark", "move", "--from", "closest_bookmark(@- ~ description('WIP ALL')::)", "--to", "@"]
push = ["git", "push", "-N"]
# run after jj git fetch to update working tree
retrunk = ["rebase", "-d", "main@origin", "-s", "all:(stack()~stack()+~immutable())"]
# prepare commits for PR (needs -r flag)
prepare = ["rebase", "-B", "description('WIP ALL') & stack()", "-A", "main@origin"]
prep = ["prepare"]
preparethis = ["rebase", "-B", "description('WIP ALL') & stack()", "-A", "main@origin", "-r", "@"]
prepthis = ["preparethis"]
bc=["b", "c", "-r", "@"]
# rebases commits also on top of main for fixing PR conflicts without rebasing the entire branch and force-pushing
rebase-main = ["rebase", "-s", "@", "-d", "@-", "-d", "main@origin"]

open = ["log", "-r", "open() & committer_date(after:'7 days ago')"]
open-all = ["log", "-r", "open()"]
open-stale = ["log", "-r", "open() & committer_date(before:'7 days ago')"]

[revset-aliases]
"parents()" = "trunk()..@-"

#"immutable_heads()" = "builtin_immutable_heads() | (trunk().. & ~mine())"
"immutable_heads()" = "builtin_immutable_heads() | (trunk().. & ~mine()) | remote_bookmarks()"


'closest_bookmark(to)' = 'heads(::to & bookmarks())'

# stack(x, n) is the set of commits reachable from 'x' not on trunk(), with 'n'
# parents. 'n' is often useful to customize the display and return set for
# certain operations. 'x' can be used to target the set of 'roots' to traverse,
# e.g. @ is the current stack.
'stack()' = 'reachable(@, ~::trunk())'
'stack(x)' = 'reachable(x, ~::trunk())'
'stack(x, n)' = 'ancestors(reachable(x, ~::trunk()), n)'

# The current set of "open" works. It is defined as:
#
# - given the set of commits not in trunk, that are written by me,
# - calculate the given stack() for each of those commits
#
# n = 1, meaning that nothing from `trunk()` is included, so all resulting
# commits are mutable by definition.
'open()' = 'stack(trunk().. & mine(), 1)'

#'branchdiff()' = 'stack() ~..'
#'branchdiff(x)' = 'stack(x) ~x..'

'wipcurrent()' = 'stack() & description("WIP CURRENT")'

[template-aliases]
'commit_timestamp(commit)' = '''
		if(commit.current_working_copy() || commit.hidden(),
			commit.committer().timestamp().ago(),
			commit.author().timestamp().ago()
		)
	'''
'format_short_change_id(id)' = 'id.shortest(6)'
'format_clickable_change_id(id)' = '''
		label("clickable", id.shortest(6))
	'''
'format_short_change_id_with_hidden_and_divergent_info(commit)' = '''
		if(commit.hidden(),
			label("hidden",
				format_clickable_change_id(commit.change_id()) ++
				" hidden"
			),
			label(if(commit.divergent(), "divergent"),
				format_clickable_change_id(commit.change_id()) ++
				if(commit.divergent(), "?")
			)
		)
	'''
'format_short_commit_id(id)' = 'id.shortest(6)'
'format_short_signature(signature)' = '''
		coalesce(signature.email().local(), email_placeholder)'''
'format_timestamp(timestamp)' = 'timestamp'

[templates]
log_node = '''
  label("node",
    coalesce(
      if(!self, label("elided", "~")),
      if(current_working_copy, label("working_copy", "@")),
      if(conflict, label("conflict", "×")),
      if(immutable, label("immutable", "◆")),
      if(self.contained_in('heads(stack())'), label("head", "┌")),
      label("normal", "├")
    )
  )
'''

log = '''
  if(root,
    format_root_commit(self),
    label(if(current_working_copy, "working_copy"),
      concat(
        separate(" ",
          format_short_change_id_with_hidden_and_divergent_info(self),
          if(conflict, label(format_short_commit_id(commit_id), format_short_commit_id(commit_id))),
          if(empty, label("empty", "(empty)")),
          if(description,
            description.first_line(),
            label(if(empty, "empty"), description_placeholder),
          ),
          bookmarks,
          tags,
          working_copies,
          if(conflict, label("conflict", "conflict")),
          if(config("ui.show-cryptographic-signatures").as_boolean(),
            format_short_cryptographic_signature(signature)),
        ) ++ "\n",
      ),
    )
  )
'''

[colors]
"empty description placeholder" = "red"
"working_copy empty description placeholder" = "red"
"working_copy description" = "bright green"
